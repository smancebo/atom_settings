{"version":3,"sources":["../src/elementTree.js"],"names":["buildElementTree","buildTokenList","babylon","ast","tokens","firstToken","start","end","length","buildElementTreeItem","token","pos","state","elementType","type","childProps","value","key","error","SyntaxError","loc","childElements","i","childAst","Array","isArray","j","sort","ast1","ast2","NodeClass","Error","children","childElementIndex","childElement","EmptyNodeClass","nextChild","endOfAstReached","addedTokenType","createFromToken","codeTokens","code","prevPos","result","processToken","substring","sourceCode","tt","tokTypes","source","name","semi","comma","parenL","parenR","braceL","braceR","slash","dot","bracketL","bracketR","ellipsis","arrow","star","incDec","colon","question","backQuote","dollarBraceL","at","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","exponent","prefix","doubleColon","isAssign","label","template","jsxTagStart","jsxTagEnd","jsxName","jsxText","keyword","num","string","regexp","eof","slice"],"mappings":"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","file":"elementTree.js","sourcesContent":["/* @flow */\n\nimport * as babylon from 'babylon';\n\nimport type Program from './elements/types/Program';\nimport type Location from './elements/Element';\n\nimport visitorKeys from './visitorKeys';\nimport elementIndex from './elements/elementIndex';\nimport Token from './elements/Token';\n\nexport type BabylonToken = {\n    type: string,\n    value: string,\n    start: number,\n    end: number,\n    loc?: Location,\n    sourceCode: string\n};\n\n/**\n * Creates CST using AST and token list.\n *\n * @param {Object} ast\n * @param {Array} tokens\n * @returns {Program}\n */\nexport function buildElementTree(ast: Object, tokens: Array<BabylonToken>): Program {\n    var firstToken = tokens[0];\n    ast.start = firstToken.start;\n    ast.end = tokens[tokens.length - 1].end;\n    return ((buildElementTreeItem(ast, {\n        tokens,\n        token: firstToken,\n        pos: 0\n    }): any): Program);\n}\n\ntype ElementTreeItemState = {\n    tokens: Array<BabylonToken>,\n    token: BabylonToken,\n    pos: number\n};\n\n/**\n * @param {Object} ast\n * @param {{tokens: Array, token: Object, pos: Number}} state\n * @returns {Element}\n */\nfunction buildElementTreeItem(ast: Object, state: ElementTreeItemState): ?Element {\n    var elementType = ast.type;\n    let childProps = visitorKeys[elementType];\n\n    // Skip first `Identifier` for ({ test = 1 } = {})\n    // since it is already used in `AssignmentPattern`\n    // Need to fix this one day (See https://github.com/babel/babylon/issues/49)\n    if (\n        ast.type === 'ObjectProperty' &&\n        ast.value.type === 'AssignmentPattern'\n    ) {\n        delete ast.key;\n    }\n\n    if (!childProps) {\n        let error = new SyntaxError(`Cannot iterate using ${elementType}`);\n        error.loc = ast.loc.start;\n        throw error;\n    }\n\n    let childElements = [];\n    for (let i = 0; i < childProps.length; i++) {\n        let childAst = ast[childProps[i]];\n\n        if (!childAst) {\n            continue;\n        }\n\n        if (Array.isArray(childAst)) {\n            for (let j = 0; j < childAst.length; j++) {\n                if (childAst[j] === null) {\n                    continue;\n                }\n\n                childElements[childElements.length] = childAst[j];\n            }\n        } else {\n            childElements[childElements.length] = childAst;\n        }\n    }\n\n    childElements.sort((ast1, ast2) => {\n        return ast1.start < ast2.start ? -1 : (ast1.start > ast2.start ? 1 : 0);\n    });\n\n    let NodeClass = elementIndex[elementType];\n\n    if (!NodeClass) {\n        throw new Error(`Cannot create ${elementType} instance`);\n    }\n\n    let children = [];\n    let childElementIndex = 0;\n    let childElement = childElements[0];\n    let end = ast.end;\n\n    do {\n        if (childElement && state.token.start === childElement.start) {\n            if (state.token.end > childElement.end) {\n                let EmptyNodeClass = elementIndex[childElement.type];\n                if (!EmptyNodeClass) {\n                    throw new Error(`Cannot create ${childElement.type} instance`);\n                }\n\n                children[children.length] = new EmptyNodeClass([]);\n                childElement = childElements[++childElementIndex];\n            } else {\n                let nextChild = childElements[childElementIndex + 1];\n\n                children[children.length] = buildElementTreeItem(childElement, state);\n                childElement = childElements[++childElementIndex];\n\n                if (!state.token ||\n                    (state.token.start === end && (state.token.end !== end || elementType !== 'Program'))\n                ) {\n                    return new NodeClass(children);\n                }\n            }\n        } else {\n            let endOfAstReached = state.token.end === end;\n            let addedTokenType = state.token.type;\n\n            if (endOfAstReached && ast.type === 'Identifier' && addedTokenType === 'Keyword') {\n                state.token.type = addedTokenType = 'Identifier';\n            }\n\n            children[children.length] = Token.createFromToken(state.token);\n\n            state.pos++;\n            state.token = state.tokens[state.pos];\n\n            if (elementType === 'Program' && addedTokenType !== 'EOF') {\n                continue;\n            }\n\n            if (endOfAstReached) {\n                return new NodeClass(children);\n            }\n        }\n    } while (state.token);\n}\n\n/**\n * Build single token list using code tokens, comments and whitespace.\n *\n * @param {Array} codeTokens\n * @param {String} code\n * @returns {Array}\n */\nexport function buildTokenList(codeTokens: Array<BabylonToken>, code: string): Array<BabylonToken> {\n    let prevPos = 0;\n    let result = [];\n\n    for (var i = 0; i < codeTokens.length; i++) {\n        let token = processToken(codeTokens[i], code);\n\n        let pos = token.start;\n        if (prevPos !== pos) {\n            let value = code.substring(prevPos, pos);\n            result[result.length] = {\n                type: 'Whitespace',\n                value,\n                sourceCode: value,\n                start: prevPos,\n                end: pos\n            };\n        }\n        result[result.length] = token;\n\n        prevPos = token.end;\n    }\n\n    return result;\n}\n\n/**\n * Babylon token types.\n */\nlet tt = babylon.tokTypes;\n\n/**\n * Transforms Babylon-style token to Esprima-style token.\n *\n * @param {Object} token\n * @param {String} source\n */\nfunction processToken(token: Object, source: string): BabylonToken {\n    var type = token.type;\n\n    if (type === tt.name) {\n        token.type = 'Identifier';\n    } else if (type === tt.semi || type === tt.comma ||\n        type === tt.parenL || type === tt.parenR ||\n        type === tt.braceL || type === tt.braceR ||\n        type === tt.slash || type === tt.dot ||\n        type === tt.bracketL || type === tt.bracketR ||\n        type === tt.ellipsis || type === tt.arrow ||\n        type === tt.star || type === tt.incDec ||\n        type === tt.colon || type === tt.question ||\n        type === tt.backQuote ||\n        type === tt.dollarBraceL || type === tt.at ||\n        type === tt.logicalOR || type === tt.logicalAND ||\n        type === tt.bitwiseOR || type === tt.bitwiseXOR ||\n        type === tt.bitwiseAND || type === tt.equality ||\n        type === tt.relational || type === tt.bitShift ||\n        type === tt.plusMin || type === tt.modulo ||\n        type === tt.exponent || type === tt.prefix ||\n        type === tt.doubleColon ||\n        type.isAssign) {\n        token.type = 'Punctuator';\n        if (!token.value) {\n            token.sourceCode = token.value = type.label;\n        }\n    } else if (type === tt.template) {\n        token.type = 'Template';\n        token.sourceCode = token.value;\n    } else if (type === tt.jsxTagStart) {\n        token.type = 'Punctuator';\n        token.sourceCode = token.value = '<';\n    } else if (type === tt.jsxTagEnd) {\n        token.type = 'Punctuator';\n        token.sourceCode = token.value = '>';\n    } else if (type === tt.jsxName) {\n        token.type = 'JSXIdentifier';\n    } else if (type === tt.jsxText) {\n        token.type = 'JSXText';\n    } else if (type.keyword === 'null') {\n        token.type = 'Null';\n        token.value = null;\n    } else if (type.keyword === 'false' || type.keyword === 'true') {\n        token.type = 'Boolean';\n        token.value = type.keyword === 'true';\n    } else if (type.keyword) {\n        token.type = 'Keyword';\n    } else if (type === tt.num) {\n        token.type = 'Numeric';\n    } else if (type === tt.string) {\n        token.type = 'String';\n    } else if (type === tt.regexp) {\n        token.type = 'RegularExpression';\n    } else if (type === 'CommentLine') {\n        token.sourceCode = '//' + token.value;\n    } else if (type === 'CommentBlock') {\n        token.sourceCode = '/*' + token.value + '*/';\n    } else if (type === tt.eof) {\n        token.type = 'EOF';\n        token.sourceCode = token.value = '';\n    }\n\n    if (!('sourceCode' in token)) {\n        token.sourceCode = source.slice(token.start, token.end);\n    }\n\n    return token;\n}\n"]}