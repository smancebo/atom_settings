{"version":3,"sources":["../src/Traverse.js"],"names":["Traverse","_nodeIndex","ElementIndexByType","_tokenIndex","type","select","value","tokens","filter","token","elements","nodeIndex","tokenIndex","i","length","addElementTree","element","isToken","addElement","child","firstChild","nextSibling","removeElementTree","removeElement","_index","items","concat","splice","indexOf"],"mappings":";;;;;;;;;;;;;;;;IAMqBA,Q;AACjB,wBAAc;AAAA;;AACV,aAAKC,UAAL,GAAkB,IAAIC,kBAAJ,EAAlB;AACA,aAAKC,WAAL,GAAmB,IAAID,kBAAJ,EAAnB;AACH;;;;0CAKiBE,I,EAA2B;AACzC,mBAAO,KAAKH,UAAL,CAAgBI,MAAhB,CAAuBD,IAAvB,CAAP;AACH;;;2CAEkBA,I,EAA4B;AAC3C,mBAAO,KAAKD,WAAL,CAAiBE,MAAjB,CAAwBD,IAAxB,CAAP;AACH;;;mDAE0BA,I,EAAcE,K,EAA6B;AAClE,gBAAIC,SAAS,KAAKJ,WAAL,CAAiBE,MAAjB,CAAwBD,IAAxB,CAAb;;AAEA,gBAAIE,KAAJ,EAAW;AACP,uBAAOC,OAAOC,MAAP,CAAc,UAASC,KAAT,EAAgB;AACjC,2BAAOA,MAAMH,KAAN,KAAgBA,KAAvB;AACH,iBAFM,CAAP;AAGH;;AAED,mBAAOC,MAAP;AACH;;;oCAEWG,Q,EAAgC;AACxC,gBAAIC,YAAY,KAAKV,UAArB;AACA,gBAAIW,aAAa,KAAKT,WAAtB;;AAEA,iBAAK,IAAIU,IAAI,CAAb,EAAgBA,IAAIH,SAASI,MAA7B,EAAqCD,GAArC,EAA0C;AACtCE,+BAAeL,SAASG,CAAT,CAAf;AACH;;AAED,qBAASE,cAAT,CAAwBC,OAAxB,EAAiC;AAC7B,oBAAIA,QAAQC,OAAZ,EAAqB;AACjBL,+BAAWM,UAAX,CAAsBF,OAAtB;AACH,iBAFD,MAEO;AACHL,8BAAUO,UAAV,CAAqBF,OAArB;AACA,wBAAIG,QAAQH,QAAQI,UAApB;AACA,2BAAOD,KAAP,EAAc;AACVJ,uCAAeI,KAAf;AACAA,gCAAQA,MAAME,WAAd;AACH;AACJ;AACJ;AACJ;;;uCAEcX,Q,EAAgC;AAC3C,gBAAIC,YAAY,KAAKV,UAArB;AACA,gBAAIW,aAAa,KAAKT,WAAtB;;AAEA,iBAAK,IAAIU,IAAI,CAAb,EAAgBA,IAAIH,SAASI,MAA7B,EAAqCD,GAArC,EAA0C;AACtCS,kCAAkBZ,SAASG,CAAT,CAAlB;AACH;;AAED,qBAASS,iBAAT,CAA2BN,OAA3B,EAAoC;AAChC,oBAAIA,QAAQC,OAAZ,EAAqB;AACjBL,+BAAWW,aAAX,CAAyBP,OAAzB;AACH,iBAFD,MAEO;AACHL,8BAAUY,aAAV,CAAwBP,OAAxB;AACA,wBAAIG,QAAQH,QAAQI,UAApB;AACA,2BAAOD,KAAP,EAAc;AACVG,0CAAkBH,KAAlB;AACAA,gCAAQA,MAAME,WAAd;AACH;AACJ;AACJ;AACJ;;;;;kBAvEgBrB,Q;;IA0EfE,kB;AACF,kCAAc;AAAA;;AACV,aAAKsB,MAAL,GAAc,EAAd;AACH;;;;+BAIMpB,I,EAA0B;AAC7B,gBAAIqB,QAAQ,KAAKD,MAAL,CAAYpB,IAAZ,CAAZ;AACA,gBAAIqB,KAAJ,EAAW;AACP,uBAAOA,MAAMC,MAAN,EAAP;AACH,aAFD,MAEO;AACH,uBAAO,EAAP;AACH;AACJ;;;mCAEUV,O,EAAwB;AAC/B,gBAAIS,QAAQ,KAAKD,MAAL,CAAYR,QAAQZ,IAApB,CAAZ;AACA,gBAAI,CAACqB,KAAL,EAAY;AACRA,wBAAQ,KAAKD,MAAL,CAAYR,QAAQZ,IAApB,IAA4B,EAApC;AACH;AACDqB,kBAAMA,MAAMX,MAAZ,IAAsBE,OAAtB;AACH;;;sCAEaA,O,EAAwB;AAClC,gBAAIS,QAAQ,KAAKD,MAAL,CAAYR,QAAQZ,IAApB,CAAZ;AACAqB,kBAAME,MAAN,CAAaF,MAAMG,OAAN,CAAcZ,OAAd,CAAb,EAAqC,CAArC;AACH","file":"Traverse.js","sourcesContent":["/* @flow */\n\nimport type Element from './elements/Element';\nimport type Node from './elements/Node';\nimport type Token from './elements/Token';\n\nexport default class Traverse {\n    constructor() {\n        this._nodeIndex = new ElementIndexByType();\n        this._tokenIndex = new ElementIndexByType();\n    }\n\n    _nodeIndex: ElementIndexByType;\n    _tokenIndex: ElementIndexByType;\n\n    selectNodesByType(type: string): Array<Node> {\n        return this._nodeIndex.select(type);\n    }\n\n    selectTokensByType(type: string): Array<Token> {\n        return this._tokenIndex.select(type);\n    }\n\n    selectTokensByTypeAndValue(type: string, value: string): Array<Token> {\n        let tokens = this._tokenIndex.select(type);\n\n        if (value) {\n            return tokens.filter(function(token) {\n                return token.value === value;\n            });\n        }\n\n        return tokens;\n    }\n\n    addElements(elements: Array<Element>): void {\n        let nodeIndex = this._nodeIndex;\n        let tokenIndex = this._tokenIndex;\n\n        for (let i = 0; i < elements.length; i++) {\n            addElementTree(elements[i]);\n        }\n\n        function addElementTree(element) {\n            if (element.isToken) {\n                tokenIndex.addElement(element);\n            } else {\n                nodeIndex.addElement(element);\n                let child = element.firstChild;\n                while (child) {\n                    addElementTree(child);\n                    child = child.nextSibling;\n                }\n            }\n        }\n    }\n\n    removeElements(elements: Array<Element>): void {\n        let nodeIndex = this._nodeIndex;\n        let tokenIndex = this._tokenIndex;\n\n        for (let i = 0; i < elements.length; i++) {\n            removeElementTree(elements[i]);\n        }\n\n        function removeElementTree(element) {\n            if (element.isToken) {\n                tokenIndex.removeElement(element);\n            } else {\n                nodeIndex.removeElement(element);\n                let child = element.firstChild;\n                while (child) {\n                    removeElementTree(child);\n                    child = child.nextSibling;\n                }\n            }\n        }\n    }\n}\n\nclass ElementIndexByType {\n    constructor() {\n        this._index = {};\n    }\n\n    _index: Object;\n\n    select(type: string): Array<any> {\n        let items = this._index[type];\n        if (items) {\n            return items.concat();\n        } else {\n            return [];\n        }\n    }\n\n    addElement(element: Element): void {\n        let items = this._index[element.type];\n        if (!items) {\n            items = this._index[element.type] = [];\n        }\n        items[items.length] = element;\n    }\n\n    removeElement(element: Element): void {\n        let items = this._index[element.type];\n        items.splice(items.indexOf(element), 1);\n    }\n}\n"]}